{"ast":null,"code":"import React, { useEffect } from 'react';\nimport { QUERY_PRODUCTS } from './queries';\nimport { UPDATE_PRODUCTS } from './actions';\nimport { useQuery } from '@apollo/client';\nimport { useStoreContext } from './GlobalState';\nexport function pluralize(name, count) {\n  if (count === 1) {\n    return name;\n  }\n  return name + 's';\n}\nexport function idbPromise(storeName, method, object) {\n  return new Promise((resolve, reject) => {\n    //open connection to the database `shop-shop` with the version of 1\n    const request = window.indexedDB.open('shop-shop', 1);\n\n    //create variables to hold reference to the database, transaction (tx), and object store\n    let db, tx, store;\n\n    // if version has changed (or if this is the first time using the database), run this method and create the three object stores\n    request.onupgradeneeded = function (e) {\n      const db = request.result;\n      //create object store for each type of data and set \"primar\" key index to be the '_id' of the data\n      db.createObjectStore('products', {\n        keyPath: '_id'\n      });\n      db.createObjectStore('categories', {\n        keyPath: '_id'\n      });\n      db.createObjectStore('cart', {\n        keyPath: '_id'\n      });\n    };\n\n    //handle any errors with conenecting\n    request.onerror = function (e) {\n      console.log('There was an error');\n    };\n\n    //on database open success\n    request.onsuccess = function (e) {\n      //save a reference of the daatabse to the 'db' variable\n      db = request.result;\n      //open a transaction do whatever we pass into 'storeName' (must match one of the object store names)\n      tx = db.transaction(storeName, 'readwrite');\n      //save a refgerence tot hat object store\n      store = tx.objectStore(storeName);\n\n      //if there's any errors let us know\n      db.onerror = function (e) {\n        console.log('error', e);\n      };\n      switch (method) {\n        case 'put':\n          store.put(object);\n          resolve(object);\n          break;\n        case 'get':\n          const all = store.getAll();\n          all.onsuccess = function () {\n            resolve(all.result);\n          };\n          break;\n        case 'delete':\n          store.delete(object._id);\n          break;\n        default:\n          console.log('No valid method');\n          break;\n      }\n\n      //when the transaction is complete close the connection\n      tx.oncomplete = function () {\n        db.close();\n      };\n    };\n  });\n}\nexport default function sortProducts(sortOption, products) {\n  const [state, dispatch] = useStoreContext();\n  const {\n    loading,\n    data\n  } = useQuery(QUERY_PRODUCTS);\n  useEffect(() => {\n    //if there's data to be stored\n    if (data) {\n      //store it in the global state object\n      dispatch({\n        type: UPDATE_PRODUCTS,\n        products: data.products\n      });\n\n      //but also take each product and save it to IndexedDB using the helper function\n      data.products.forEach(product => {\n        idbPromise('products', 'put', product);\n      });\n      //add else if to check if 'loading' is undefined in 'useQuery()' hook\n    } else if (!loading) {\n      //since we're offline, get all of the data from the 'products' store\n      idbPromise('products', 'get').then(products => {\n        dispatch({\n          type: UPDATE_PRODUCTS,\n          products: products\n        });\n      });\n    }\n  }, [data, loading, dispatch]);\n  if (sortOption === 'Name') {\n    const productsArr = products.products.slice().sort((a, b) => a.name.localeCompare(b.name));\n  } else if (sortOption === 'Price Low to High') {\n    products.products.slice().sort((a, b) => a.price - b.price);\n  } else if (sortOption === 'Price High to Low') {\n    products.products.slice().sort((a, b) => b.price - a.price);\n  } else {}\n}","map":{"version":3,"names":["React","useEffect","QUERY_PRODUCTS","UPDATE_PRODUCTS","useQuery","useStoreContext","pluralize","name","count","idbPromise","storeName","method","object","Promise","resolve","reject","request","window","indexedDB","open","db","tx","store","onupgradeneeded","e","result","createObjectStore","keyPath","onerror","console","log","onsuccess","transaction","objectStore","put","all","getAll","delete","_id","oncomplete","close","sortProducts","sortOption","products","state","dispatch","loading","data","type","forEach","product","then","productsArr","slice","sort","a","b","localeCompare","price"],"sources":["C:/Users/tdegi/OneDrive/Desktop/Bootcamp/Repository/fifth-street/client/src/utils/helpers.js"],"sourcesContent":["import React, { useEffect } from 'react';\nimport { QUERY_PRODUCTS } from './queries';\nimport { UPDATE_PRODUCTS } from './actions';\nimport { useQuery } from '@apollo/client';\nimport { useStoreContext } from './GlobalState';\n\nexport function pluralize(name, count) {\n  if (count === 1) {\n    return name\n  }\n  return name + 's'\n}\n\nexport function idbPromise(storeName, method, object) {\n  return new Promise((resolve, reject) => {\n    //open connection to the database `shop-shop` with the version of 1\n    const request = window.indexedDB.open('shop-shop', 1);\n\n    //create variables to hold reference to the database, transaction (tx), and object store\n    let db, tx, store;\n\n    // if version has changed (or if this is the first time using the database), run this method and create the three object stores\n    request.onupgradeneeded = function(e) {\n      const db = request.result;\n      //create object store for each type of data and set \"primar\" key index to be the '_id' of the data\n      db.createObjectStore('products', { keyPath: '_id' });\n      db.createObjectStore('categories', { keyPath: '_id' });\n      db.createObjectStore('cart', { keyPath: '_id' });\n    };\n\n    //handle any errors with conenecting\n    request.onerror = function(e) {\n      console.log('There was an error');\n    };\n\n    //on database open success\n    request.onsuccess = function(e) {\n      //save a reference of the daatabse to the 'db' variable\n      db = request.result;\n      //open a transaction do whatever we pass into 'storeName' (must match one of the object store names)\n      tx = db.transaction(storeName, 'readwrite');\n      //save a refgerence tot hat object store\n      store = tx.objectStore(storeName);\n\n      //if there's any errors let us know\n      db.onerror = function(e) {\n        console.log('error', e);\n      };\n\n      switch (method) {\n        case 'put':\n          store.put(object);\n          resolve(object);\n          break;\n        case 'get':\n          const all = store.getAll();\n          all.onsuccess=function() {\n            resolve(all.result);\n          };\n        break;\n        case 'delete':\n          store.delete(object._id);\n          break;\n        default:\n          console.log('No valid method');\n          break;\n      }\n\n      //when the transaction is complete close the connection\n      tx.oncomplete = function() {\n        db.close();\n      };\n    };\n\n\n  });\n}\n\nexport default function sortProducts(sortOption, products) {\n  const [state, dispatch] = useStoreContext();\n  const { loading, data } = useQuery(QUERY_PRODUCTS);\n  useEffect(() => {\n    //if there's data to be stored\n    if (data) {\n      //store it in the global state object\n      dispatch({\n        type: UPDATE_PRODUCTS,\n        products: data.products\n      });\n\n      //but also take each product and save it to IndexedDB using the helper function\n      data.products.forEach((product) => {\n        idbPromise('products', 'put', product);\n      });\n      //add else if to check if 'loading' is undefined in 'useQuery()' hook\n    } else if (!loading) {\n      //since we're offline, get all of the data from the 'products' store\n      idbPromise('products', 'get').then((products) => {\n        dispatch({\n          type: UPDATE_PRODUCTS,\n          products: products\n        });\n      });\n    }\n  }, [data, loading, dispatch]);\n\n  if (sortOption==='Name') {\n    const productsArr = products.products.slice().sort((a,b) => a.name.localeCompare(b.name));\n\n  } else if (sortOption==='Price Low to High') {\n    products.products.slice().sort((a, b) => a.price - b.price);\n  } else if (sortOption==='Price High to Low'){\n    products.products.slice().sort((a, b) => b.price - a.price);\n  } else {\n  }\n}\n\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}